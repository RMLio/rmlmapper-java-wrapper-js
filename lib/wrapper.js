/**
 * author: Pieter Heyvaert (pheyvaer.heyvaert@ugent.be)
 * Ghent University - imec - IDLab
 */

const path = require('path');
const fs = require('fs-extra');
const fsTraditional = require('fs');
const spawn = require('child_process').spawn;
const N3 = require('n3');
const {DataFactory, Parser, Writer} = N3;
const {literal, quad, namedNode} = DataFactory;
const newQuad = quad;
const {strToQuads} = require('./utils');
const { v4: uuidv4 } = require('uuid');
const sha384 = require("crypto-js/sha384");

const sourceFilePrefix = 'data-';
const targetFilePrefix = 'target-';

class RMLMapperWrapper {

  /**
   * Creates a new RMLMapperWrapper instance
   * @param path - The path to the RMLMapper jar file.
   * @param {string} tempFolder - The path to a folder that will be used to create temporary processing folders.
   * @param {boolean} removeTempFolders - Remove temporary folders after execution af an RML mapping.
   * @param {string} [stateFolder=tempFolder + "/function_state"] - Specify folder to keep state between executions.
   * @param {number} [stateFolderTimeToLive = 600] - Specify the minimal time in seconds to keep state.
   * @param {Object} javaVMOptions - Options passed to the Java Virtual Machine running RMLMapper.
   */
  constructor(path, tempFolder, removeTempFolders, stateFolder = tempFolder + "/function_state", stateFolderTimeToLive = 600, javaVMOptions = {}) {
    this.path = path;
    this.tempFolder = tempFolder;
    this.removeTempFolders = removeTempFolders;

    // folder to keep state of functions during RML mapping execution
    this.stateFolder = this._fixPath(stateFolder);

    // how long to keep state folders, in seconds. The default is 10 minutes
    this.stateFolderTimeToLive = stateFolderTimeToLive;

    this.javaVMOptions = javaVMOptions

    //check if temp directory exists
    if (!fs.existsSync(this.tempFolder)) {
      fs.mkdirSync(this.tempFolder);
    }

    // check if state directory exists
    if (!fs.existsSync(this.stateFolder)) {
      fs.mkdirSync(this.stateFolder);
    }
  }

  /**
   * This function returns the RDF generated by using the provided RML rules.
   * @param rml - The RML rules are either provided as a string in an RDF format or an array of quads.
   * @param {Object} options - Additional options that you can provide to this function.
   * @param {Object} options.sources - A map of sources where the key is the value used in rml:source in the RML rules
   * and the value is the content of the source. (required)
   * @param {boolean} options.generateMetadata - Set to true to generate metadata about the execution of the rules. (optional)
   * @param {boolean} options.asQuads - Set to true to return the generated RDF as quads. (optional)
   * @param options.fno - The RML rules are either provided as a string in an RDF format or an array of quads.
   * @param {string} options.functionStateId - Id for state: if a functions keeps state, users can refer to that state with this id.
   * @param {serialization} options.serialization - Set to a preferred serialization for the generated RDF. (optional)
   * This option can be not be combined with asQuads.
   * @returns {Promise<unknown>}
   */
  async execute(rml, options = {}) {
    if (typeof rml === 'string' || rml instanceof String) {
      rml = await this._convertRDFStringToQuads(rml);
    }

    options = Object.assign({
      generateMetadata: false,
      asQuads: false,
      serialization: 'nquads'
    }, options);

    if (!options.asQuads && options.serialization) {
      options.serialization = this._sanitizeSerialization(options.serialization);
    } else {
      options.serialization = 'nquads';
    }

    if (options.fno && typeof options.fno === 'string' || options.fno instanceof String) {
      options.fno = await this._convertRDFStringToQuads(options.fno);
    }

    return new Promise(async (resolve, reject) => {
      // current time
      const ms = new Date().getTime();
      // folder where the data used by the RMLMapper is stored
      const processDir = path.join(this.tempFolder, '' + ms);

      await fs.mkdir(processDir);

      const logFile = path.join(processDir, 'rmlmapper.log');
      const sourceDirPrefix = this._fixPath(path.join(processDir, sourceFilePrefix));
      const targetDirPrefix = this._fixPath(path.join(processDir, targetFilePrefix));

      if (options.sources) {
        this._sanitizeSources(options.sources);
        await this._saveSources(options.sources, sourceDirPrefix);
      }

      try {
        const result = await this._executeCLI({
          rml,
          sourceDirPrefix,
          processDir,
          logFile,
          serialization: options.serialization,
          asQuads: options.asQuads,
          generateMetadata: options.generateMetadata,
          fno: options.fno,
          targetDirPrefix,
          sources: options.sources,
          functionStateId: options.functionStateId  // functionStateId is an identifier that the caller can use to refer to its own specific state.
        });
        resolve(result)
      } catch (e) {
        reject(e);
      }
    });
  }

  async _executeCLI(options) {
    let {rml, sourceDirPrefix, sources, processDir, logFile, serialization, asQuads, generateMetadata, fno, targetDirPrefix, functionStateId} = options;
    const mappingFile = this._fixPath(path.join(processDir, 'mapping.rml.ttl'));
    let functionsFile;

    const result = this._updateTargetsWithLocalFiles({rmlQuads: rml, dirPrefix: targetDirPrefix});
    rml = result.rml;
    const targetFiles = result.targetFiles;
    const rmlStr = await this._setSourcesInRMLRules(rml, sourceDirPrefix, sources);

    await fs.writeFile(mappingFile, rmlStr);
    const outputFile = path.join(processDir, "output." + serialization);
    const metadataFile = this._fixPath(path.join(processDir, "metadata." + serialization));

    if (fno) {
      functionsFile = path.join(processDir, 'functions.ttl');
      const fnoWriter =  new Writer({format: 'text/turtle'});
      const fnoStr = fnoWriter.quadsToString(fno);
      await fs.writeFile(functionsFile, fnoStr);
    }

    if (functionStateId) {
      // clean up old state dirs
      await this._cleanUpStateFolder();
      // hash the function state id; you never know what's in there
      const hashedStateId = sha384(functionStateId).toString();
      this.javaVMOptions.DifState = this._fixPath(path.join(this.stateFolder, hashedStateId));
    }

    let execCommand = `java`;
    let execParams = [];

    Object.keys(this.javaVMOptions).forEach(key => {
      const value = this.javaVMOptions[key];
      execParams.push(`-${key}=${value}`);
    });

    execParams.push('-jar')
    execParams.push(this.path)
    execParams.push(`-m`)
    execParams.push(mappingFile)
    execParams.push(`-o`)
    execParams.push(outputFile)
    execParams.push(`-s`)
    execParams.push(serialization)

    if (generateMetadata) {
      execParams.push(`-l`)
      execParams.push(`triple`)
      execParams.push(`-e`)
      execParams.push(metadataFile)
    }

    if (fno) {
      execParams.push(`-f`)
      execParams.push(functionsFile)
    }

    return new Promise((resolve, reject) => {
      const mapping = spawn(execCommand, execParams, {
        // setting CWD when you have a mapping file that accesses (large) files directly
        // so you don't need to needlessly copy that file
        cwd: path.resolve(processDir, '../../')
      });
      let stdout = '';
      let stderr = '';
      mapping.stdout.on('data', data => {
        stdout += data;
      })
      mapping.stderr.on('data', data => {
        stderr += data;
      })
      mapping.on('close', async (code) => {
        if (code !== 0 || stderr && stderr.indexOf('ERROR') >= 0) {
          const err = new Error(`Error while executing the rules.`);
        if (stderr) {
          await fs.writeFile(logFile, stderr);
          err.log = stderr;
          }
          reject(err);
        }
          try {
            let output = await fs.readFile(outputFile, 'utf8');

            if (asQuads) {
              output = await strToQuads(output);
            }

            const targets = {};

            for (let i = 0; i < targetFiles.length; i++){
              const file = targetFiles[i];

              try {
                targets[path.basename(file).replace(targetFilePrefix, '')] = await fs.readFile(file, 'utf8');
              } catch (targetError) {
                targetError.message = `Error while reading target file '${file}'`;
                reject(targetError);
              }
            }

            if (targetFiles.length > 0) {
              targets.stdout = output;
              output = targets;
            }

            if (generateMetadata) {
              try {
                let metadata = await fs.readFile(metadataFile, 'utf8');

                if (asQuads) {
                  metadata = await strToQuads(metadata);
                }

                resolve({output, metadata});
              } catch (metadataErr) {
                metadataErr.message = `Error while reading output file '${metadataFile}'`;
                reject(metadataErr);
              }
            } else {
              resolve({output});
            }
          } catch (outputError) {
            outputError.message = `Error while reading output file '${outputFile}'`;
            reject(outputError);
          }

          if (this.removeTempFolders) {
            try {
              await fs.remove(processDir);
            } catch (err) {
              err.message = `Unable to remove temp folder "${processDir}.`;
              reject(err);
            }
          }
      })
    });
  }

  _saveSources(sources, prefix) {
    return this._saveSource(Object.keys(sources), 0, sources, prefix);
  }

  async _saveSource(names, index, sources, prefix) {
    return new Promise(async (resolve, reject) => {
      const self = this;

      async function done() {
        if (index < names.length) {
          await self._saveSource(names, index + 1, sources, prefix);
        }

        resolve();
      }

      if (sources[names[index]]) {
        if (typeof sources[names[index]].data === 'string') {
          try {
            await fs.writeFile(prefix + sources[names[index]].path, sources[names[index]].data);
            done();
          } catch (err) {
            reject(err);
          }
        } else {
          reject(new Error(`The source with name "${names[index]}" is not string.`));
        }
      } else {
        done();
      }
    });
  }

  /**
   * This method converts an RDF string to an array of quads.
   * @param rdf The string with the RDF.
   * @returns {Promise<unknown>}
   * @private
   */
  _convertRDFStringToQuads(rdf) {
    return new Promise((resolve, reject) => {
      const parser = new Parser();
      const quads = [];

      parser.parse(rdf, (error, quad) => {
        if (quad) {
          quads.push(quad);
        } else if (error) {
          reject(error);
        } else {
          resolve(quads);
        }
      });
    });
  }

  /**
   * This method sets the sources in the RML rules to local files.
   * @param rmlQuads An array of quads with the RML rules.
   * @param prefix The string that needs to be added before the original value of the source.
   * @returns {Promise<unknown>}
   * @private
   */
  async _setSourcesInRMLRules(rmlQuads, prefix, sources) {
    return new Promise((resolve, reject) => {
      const adjustedRMLQuads = [];

      rmlQuads.forEach(rmlQuad => {
        let adjustedQuad = rmlQuad;

        if (rmlQuad.predicate.value === 'http://semweb.mmlab.be/ns/rml#source' && rmlQuad.object.termType === 'Literal') {
          adjustedQuad = newQuad(rmlQuad.subject, rmlQuad.predicate, literal(prefix + sources[rmlQuad.object.value].path));
        }

        adjustedRMLQuads.push(adjustedQuad);
      });

      const writer = new Writer();

      writer.addQuads(adjustedRMLQuads);
      writer.end((error, result) => {
        if (error) {
          reject(error);
        }

        resolve(result);
      });
    });
  }

  _sanitizeSerialization(serialization) {
    serialization = serialization.toLowerCase(serialization);
    return serialization.replace(/[-_]/g, '');
  }

  /**
   * Paths in the RML files can't have \\ so all \ must be replaced by /, for Windows, the RMLMapper takes care of reverting this again.
   */
  _fixPath(filePath) {
    return path.sep === '\\' ? filePath.replace(/\\/g, '/') : filePath;
  }

  _updateTargetsWithLocalFiles(options = {}) {
    let {rmlQuads, dirPrefix} = options;
    const targetFiles = [];

    if (!rmlQuads) {
      throw new Error('RML quads are missing.');
    }

    if (!dirPrefix) {
      throw new Error('Directory prefix is missing.');
    }

    if (!path.isAbsolute(dirPrefix)) {
      dirPrefix = path.join(process.cwd(), dirPrefix);
    }

    const store = new N3.Store();
    store.addQuads(rmlQuads);

    const logicalTargetNodes = store.getObjects(null, namedNode('http://semweb.mmlab.be/ns/rml#logicalTarget'));

    logicalTargetNodes.forEach(logicalTargetNode => {
      const targetNodes = store.getObjects(logicalTargetNode, namedNode('http://semweb.mmlab.be/ns/rml-target#target'));

      if (targetNodes.length > 0) {
        const targetNode = targetNodes[0];
        const voidDataDumps = store.getObjects(targetNode, namedNode('http://rdfs.org/ns/void#dataDump'));
        const dcatDataDumps = store.getObjects(targetNode, namedNode('http://www.w3.org/ns/dcat#dataDump'));

        if (voidDataDumps.length > 0) {
          const filename = path.basename(voidDataDumps[0].value);

          let p = dirPrefix + filename;
          targetFiles.push(p);
          p = this._fixPath(p);

          store.addQuad(targetNode, namedNode('http://rdfs.org/ns/void#dataDump'), namedNode('file://' + p));
          store.removeQuad(targetNode, namedNode('http://rdfs.org/ns/void#dataDump'), voidDataDumps[0]);

        } else if (dcatDataDumps.length > 0) {
          const filename = path.basename(dcatDataDumps[0].value);

          let p = dirPrefix + filename;
          targetFiles.push(p);
          p = this._fixPath(p);

          store.addQuad(targetNode, namedNode('http://www.w3.org/ns/dcat#dataDump'), namedNode('file://' + p));
          store.removeQuad(targetNode, namedNode('http://www.w3.org/ns/dcat#dataDump'), dcatDataDumps[0]);
        }
      }
    });

    return {rml: store.getQuads(), targetFiles};
  }

  _sanitizeSources(sources) {
    const filePaths = Object.keys(sources);

    filePaths.forEach(filePath => {
      sources[filePath] = {
        data: sources[filePath],
        path: uuidv4() + '-' + path.basename(filePath)
      };
    });
  }

  async _cleanUpStateFolder() {
    const stateSubFolders = await fsTraditional.promises.readdir(this.stateFolder);
    for await (const stateSubFolder of stateSubFolders) {
      const completePathToDelete = path.join(this.stateFolder, stateSubFolder);
      const stat = await fsTraditional.promises.stat(completePathToDelete);

      // calculate time passed since subfolder creation, in seconds
      const timePassed = (new Date().getTime() - stat.birthtime.getTime()) / 1000;
      if (timePassed > this.stateFolderTimeToLive) {
        await fsTraditional.promises.rmdir(completePathToDelete, {recursive: true, force: true});
      }
    }
  }
}

module.exports = RMLMapperWrapper;
