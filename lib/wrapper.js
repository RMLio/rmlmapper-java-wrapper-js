/**
 * author: Pieter Heyvaert (pheyvaer.heyvaert@ugent.be)
 * Ghent University - imec - IDLab
 */

const path = require('path');
const fs = require('fs-extra');
const exec = require('child_process').exec;
const N3 = require('n3');
const { DataFactory, Parser, Writer } = N3;
const { literal } = DataFactory;
const { strToQuads } = require('./utils');

const sourceFilePrefix = "data-";

class RMLMapperWrapper {

  constructor(path, tempFolder, removeTempFolders) {
    this.path = path;
    this.tempFolder = tempFolder;
    this.removeTempFolders = removeTempFolders;

    //check if temp directory exists
    if (!fs.existsSync(this.tempFolder)) {
      fs.mkdirSync(this.tempFolder);
    }
  }

  /**
   * This function returns the RDF generated by using the provided RML rules.
   * @param rml The RML rules are either provided as a string in an RDF format or an array of quads.
   * @param {Object} options Additional options that you can provide to this function.
   * @param {Object} options.sources A map of sources where the key is the value used in rml:source in the RML rules
   * and the value is the content of the source. (required)
   * @param {boolean} options.generateMetadata Set to true to generate metadata about the execution of the rules. (optional)
   * @param {boolean} options.asQuads Set to true to return the generated RDF as quads. (optional)
   * @param {serialization} options.serialization Set to a preferred serialization for the generated RDF. (optional)
   * This option can be not be combined with asQuads.
   * @returns {Promise<unknown>}
   */
  async execute(rml, options = {}) {
    if (typeof rml === 'string' || rml instanceof String) {
      rml = await this._convertRDFStringToQuads(rml);
    }

    options = Object.assign({
      generateMetadata: false,
      asQuads: false,
      serialization: 'nquads'
    }, options);

    if (!options.asQuads && options.serialization) {
      options.serialization = this._sanitizeSerialization(options.serialization);
    } else {
      options.serialization = 'nquads';
    }

    return new Promise((resolve, reject) => {
      // current time
      const ms = new Date().getTime();
      // folder where the data used by the RMLMapper is stored
      const processDir = path.resolve(this.tempFolder, '' +  ms);

      fs.mkdir(processDir, () => {
        const logFile = path.resolve(processDir, 'rmlmapper.log');
        const sourceDirPrefix = path.resolve(processDir, sourceFilePrefix);
        const self = this;

        const callback = async function (error) {
          if (error) {
            reject(error);
          } else {
            const mappingFile = path.resolve(processDir, 'mapping.rml.ttl');

            try {
              const rmlStr = await self._setSourcesInRMLRules(rml, sourceDirPrefix);

              fs.writeFile(mappingFile, rmlStr, function (error) {
                if (error) {
                  reject(error);
                } else {
                  const outputFile = path.resolve(processDir, "output." + options.serialization);
                  const metadataFile = path.resolve(processDir, "metadata." + options.serialization);

                  let execCommand = `java -jar ${self.path} -m ${mappingFile} -o ${outputFile} -s ${options.serialization}`;

                  if (options.generateMetadata) {
                    execCommand += ` -l triple -e ${metadataFile}`;
                  }

                  exec(execCommand, function (error, stdout, stderr) {

                    if (stderr) {
                      fs.writeFileSync(logFile, stderr);
                      const err = new Error(`Error while executing the rules.`);
                      err.log = stderr;
                      reject(err);
                    } else {
                      fs.readFile(outputFile, 'utf8', async (outputErr, output) => {
                        if (outputErr) {
                          outputErr.message = `Error while reading output file '${outputFile}'`;
                          reject(outputErr);
                        } else {
                          if (options.asQuads) {
                            output = await strToQuads(output);
                          }

                          if (options.generateMetadata) {
                            fs.readFile(metadataFile, 'utf8', async (metadataErr, metadata) => {
                              if (metadataErr) {
                                metadataErr.message = `Error while reading output file '${metadataFile}'`;
                                reject(metadataErr);
                              } else {
                                if (asQuads) {
                                  metadata = await strToQuads(metadata);
                                }

                                resolve({output, metadata});
                              }
                            });
                          } else {
                            resolve({output});
                          }
                        }

                        if (self.removeTempFolders) {
                          fs.remove(processDir, err => {
                            if (err) {
                              err.message = `Unable to remove temp folder "${processDir}.`;
                              reject(err)
                            }
                          });
                        }
                      });
                    }
                  });
                }
              });
            } catch (error) {
              reject(error);
            }
          }
        };

        if (options.sources) {
          this._saveSources(options.sources, sourceDirPrefix)
            .then(callback)
            .catch(reject);
        } else {
          callback();
        }
      });
    });
  }

  _saveSources(sources, prefix) {
    return this._saveSource(Object.keys(sources), 0, sources, prefix);
  }

  async _saveSource(names, index, sources, prefix) {
    return new Promise((resolve, reject) => {
      const self = this;

      async function done() {
        if (index < names.length) {
          await self._saveSource(names, index + 1, sources, prefix);
        }

        resolve();
      }

      if (sources[names[index]]) {
        if (typeof sources[names[index]] === 'string') {
          fs.writeFile(prefix + names[index], sources[names[index]], (err) => {
            if (err) {
              reject(err);
            }

            done();
          });
        } else {
          reject(new Error(`The source with name "${names[index]}" is not string.`));
        }
      } else {
        done();
      }
    });
  }

  /**
   * This method converts an RDF string to an array of quads.
   * @param rdf The string with the RDF.
   * @returns {Promise<unknown>}
   * @private
   */
  _convertRDFStringToQuads(rdf) {
    return new Promise((resolve, reject) => {
      const parser = new Parser();
      const quads = [];

      parser.parse(rdf, (error, quad) => {
        if (quad) {
          quads.push(quad);
        } else if (error) {
          reject(error);
        } else {
          resolve(quads);
        }
      });
    });
  }

  /**
   * This method sets the sources in the RML rules to local files.
   * @param rmlQuads An array of quads with the RML rules.
   * @param prefix The string that needs to be added before the original value of the source.
   * @returns {Promise<unknown>}
   * @private
   */
  async _setSourcesInRMLRules(rmlQuads, prefix) {
    return new Promise((resolve, reject) => {
      rmlQuads.forEach(quad => {
        if (quad.predicate.value === 'http://semweb.mmlab.be/ns/rml#source' && quad.object.termType === 'Literal') {
          quad.object = literal(prefix + quad.object.value);
        }
      });

      const writer = new Writer();

      writer.addQuads(rmlQuads);
      writer.end((error, result) => {
        if (error) {
          reject(error);
        }

        resolve(result);
      });
    });
  }

  _sanitizeSerialization(serialization) {
    serialization = serialization.toLowerCase(serialization);
    return serialization.replace(/[-_]/g, '');
  }
}

module.exports = RMLMapperWrapper;
