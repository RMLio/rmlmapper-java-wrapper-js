/**
 * author: Pieter Heyvaert (pheyvaer.heyvaert@ugent.be)
 * Ghent University - imec - IDLab
 */

const path = require('path');
const fs = require('fs-extra');
const exec = require('child_process').exec;
const N3 = require('n3');
const {DataFactory, Parser, Writer} = N3;
const {literal, quad} = DataFactory;
const newQuad = quad;
const {strToQuads} = require('./utils');

const sourceFilePrefix = "data-";

class RMLMapperWrapper {

  constructor(path, tempFolder, removeTempFolders, javaVMOptions = {}) {
    this.path = path;
    this.tempFolder = tempFolder;
    this.removeTempFolders = removeTempFolders;
    this.javaVMOptions = javaVMOptions

    //check if temp directory exists
    if (!fs.existsSync(this.tempFolder)) {
      fs.mkdirSync(this.tempFolder);
    }
  }

  /**
   * This function returns the RDF generated by using the provided RML rules.
   * @param rml - The RML rules are either provided as a string in an RDF format or an array of quads.
   * @param {Object} options - Additional options that you can provide to this function.
   * @param {Object} options.sources - A map of sources where the key is the value used in rml:source in the RML rules
   * and the value is the content of the source. (required)
   * @param {boolean} options.generateMetadata - Set to true to generate metadata about the execution of the rules. (optional)
   * @param {boolean} options.asQuads - Set to true to return the generated RDF as quads. (optional)
   * @param options.fno - The RML rules are either provided as a string in an RDF format or an array of quads.
   * @param {serialization} options.serialization - Set to a preferred serialization for the generated RDF. (optional)
   * This option can be not be combined with asQuads.
   * @returns {Promise<unknown>}
   */
  async execute(rml, options = {}) {
    if (typeof rml === 'string' || rml instanceof String) {
      rml = await this._convertRDFStringToQuads(rml);
    }

    options = Object.assign({
      generateMetadata: false,
      asQuads: false,
      serialization: 'nquads'
    }, options);

    if (!options.asQuads && options.serialization) {
      options.serialization = this._sanitizeSerialization(options.serialization);
    } else {
      options.serialization = 'nquads';
    }

    if (options.fno && typeof options.fno === 'string' || options.fno instanceof String) {
      options.fno = await this._convertRDFStringToQuads(options.fno);
    }

    return new Promise(async (resolve, reject) => {
      // current time
      const ms = new Date().getTime();
      // folder where the data used by the RMLMapper is stored
      const processDir = path.resolve(this.tempFolder, '' + ms);

      await fs.mkdir(processDir);

      const logFile = path.resolve(processDir, 'rmlmapper.log');
      const sourceDirPrefix = path.resolve(processDir, sourceFilePrefix);

      if (options.sources) {
        await this._saveSources(options.sources, sourceDirPrefix);
      }

      try {
        const result = await this._executeCLI({rml, sourceDirPrefix, processDir, logFile,
          serialization: options.serialization,
          asQuads: options.asQuads,
          generateMetadata: options.generateMetadata,
          fno: options.fno
        });
        resolve(result)
      } catch (e) {
        reject (e);
      }
    });
  }

  async _executeCLI(options) {
    const {rml, sourceDirPrefix, processDir, logFile, serialization, asQuads, generateMetadata, fno} = options;
    const mappingFile = path.resolve(processDir, 'mapping.rml.ttl');
    let functionsFile;

    const rmlStr = await this._setSourcesInRMLRules(rml, sourceDirPrefix);

    await fs.writeFile(mappingFile, rmlStr);
    const outputFile = path.resolve(processDir, "output." + serialization);
    const metadataFile = path.resolve(processDir, "metadata." + serialization);

    if (fno) {
      functionsFile = path.resolve(processDir, 'functions.ttl');
      await fs.writeFile(functionsFile, fno);
    }


    let execCommand = `java `;

    Object.keys(this.javaVMOptions).forEach(key => {
      const value = this.javaVMOptions[key];
      execCommand += `-${key}=${value} `
    });

    execCommand += `-jar ${this.path} -m ${mappingFile} -o ${outputFile} -s ${serialization}`;

    if (generateMetadata) {
      execCommand += ` -l triple -e ${metadataFile}`;
    }

    if (fno) {
      execCommand += ` -f ${functionsFile}`;
    }

    return new Promise((resolve, reject) => {
      exec(execCommand, async (error, stdout, stderr) => {
        if (stderr) {
          await fs.writeFile(logFile, stderr);
          const err = new Error(`Error while executing the rules.`);
          err.log = stderr;
          reject(err);
        } else {
          try {
            let output = await fs.readFile(outputFile, 'utf8');

            if (asQuads) {
              output = await strToQuads(output);
            }

            if (generateMetadata) {
              try {
                let metadata = await fs.readFile(metadataFile, 'utf8');

                if (asQuads) {
                  metadata = await strToQuads(metadata);
                }

                resolve({output, metadata});
              } catch (metadataErr) {
                metadataErr.message = `Error while reading output file '${metadataFile}'`;
                reject(metadataErr);
              }
            } else {
              resolve({output});
            }
          } catch (outputError) {
            outputError.message = `Error while reading output file '${outputFile}'`;
            reject(outputError);
          }

          if (this.removeTempFolders) {
            try {
              await fs.remove(processDir);
            } catch (err) {
              err.message = `Unable to remove temp folder "${processDir}.`;
              reject(err);
            }
          }
        }
      });
    });
  }

  _saveSources(sources, prefix) {
    return this._saveSource(Object.keys(sources), 0, sources, prefix);
  }

  async _saveSource(names, index, sources, prefix) {
    return new Promise((resolve, reject) => {
      const self = this;

      async function done() {
        if (index < names.length) {
          await self._saveSource(names, index + 1, sources, prefix);
        }

        resolve();
      }

      if (sources[names[index]]) {
        if (typeof sources[names[index]] === 'string') {
          fs.writeFile(prefix + names[index], sources[names[index]], (err) => {
            if (err) {
              reject(err);
            }

            done();
          });
        } else {
          reject(new Error(`The source with name "${names[index]}" is not string.`));
        }
      } else {
        done();
      }
    });
  }

  /**
   * This method converts an RDF string to an array of quads.
   * @param rdf The string with the RDF.
   * @returns {Promise<unknown>}
   * @private
   */
  _convertRDFStringToQuads(rdf) {
    return new Promise((resolve, reject) => {
      const parser = new Parser();
      const quads = [];

      parser.parse(rdf, (error, quad) => {
        if (quad) {
          quads.push(quad);
        } else if (error) {
          reject(error);
        } else {
          resolve(quads);
        }
      });
    });
  }

  /**
   * This method sets the sources in the RML rules to local files.
   * @param rmlQuads An array of quads with the RML rules.
   * @param prefix The string that needs to be added before the original value of the source.
   * @returns {Promise<unknown>}
   * @private
   */
  async _setSourcesInRMLRules(rmlQuads, prefix) {
    return new Promise((resolve, reject) => {
      const adjustedRMLQuads = [];

      rmlQuads.forEach(rmlQuad => {
        let adjustedQuad = rmlQuad;

        if (rmlQuad.predicate.value === 'http://semweb.mmlab.be/ns/rml#source' && rmlQuad.object.termType === 'Literal') {
          adjustedQuad = newQuad(rmlQuad.subject, rmlQuad.predicate, literal(prefix + rmlQuad.object.value));
        }

        adjustedRMLQuads.push(adjustedQuad);
      });

      const writer = new Writer();

      writer.addQuads(adjustedRMLQuads);
      writer.end((error, result) => {
        if (error) {
          reject(error);
        }

        resolve(result);
      });
    });
  }

  _sanitizeSerialization(serialization) {
    serialization = serialization.toLowerCase(serialization);
    return serialization.replace(/[-_]/g, '');
  }
}

module.exports = RMLMapperWrapper;
